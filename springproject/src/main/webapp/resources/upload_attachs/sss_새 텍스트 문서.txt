ENUM은 테이블 생성 시점에 컬럼 지정문에서 명확하게 계산된 허용 값 리스트에서
선택이 된 값을 사용하는 스트링 오브젝트이다.
 
그 값은 어떤 환경에서는 빈 스트링 (empty string) ('') 또는 NULL 값이 될 수도 있다:
만일 여러분이 유효하지 않은 값을 ENUM에 삽입한다면 (즉, 허용된 값 리스트에
없는 스트링), 빈 스트링이 특별 에러 값 형태로 대신 삽입된다. 이 스트링은 숫자
값으로 0 을 가진다는 사실로 인해 “일반적인(normal)” 빈 스트링과 구분이 된다.
나중에 보다 자세히 다루기로 한다.
만일 스트릭트 SQL 모드가 활성화 되어 있다면, 유효하지 않은 ENUM 값을 삽입
하고자 하는 시도는 에러를 발생 시킨다.

만일ENUM 컬럼이 NULL을 허용하도록 선언되었다면, NULL 값은 그 컬럼에 대해서
유효한 값이 되며, 그리고 디폴트 값은 NULL이 된다. 만일 ENUM 컬럼이 NOT NULL로
선언되었다면, 이것의 디폴트 값은 허용된 값 리스트의 첫 번째 요소(element)가 된다.
각각의 계산(enumeration) 값들은 인덱스를 가지고 있다:
컬럼 지정문에 있는 사용 가능 요소 리스트에서 가져오는 값은 1 부터 시작을 해서
번호를 매기게 된다.
빈 스트링 에러 값의 인덱스 값은 0 이다. 이것은 아래의 SELECT 명령문을 사용해서
유효하지 않은 ENUM 값이 어디에 할당되었는지를 찾을 수 있다는 것을 의미한다:
·     mysql> SELECT * FROM tbl_name WHERE enum_col=0;
NULL 값의 인덱스는 NULL이다.
여기에서 말하는 “인덱스(index)”는 계산 값(enumeration value) 리스트 내에 있는
위치만을 참조한다. 이것은 테이블 인덱스와는 상관이 없다.
예를 들면, ENUM('one', 'two', 'three') 형태로 지정된 컬럼은 아래에 있는 값들 중에
어떠한 것들도 가질 수가 있다. 각각의 값에 대한 인덱스 역시 아래에 있다:
Value
Index
NULL'0 '
'one'1'
'two'2
'three'3 
계산(enumeration)은 최대 65,535 요소(elements)를 가질 수 있다.
 
트레일링 스페이스는 테이블이 생성될 때 테이블 정의문에 있는 ENUM 맴버 값에서
자동으로 삭제된다.
 
데이터를 추출할 때에는, ENUM 컬럼에 저장된 값은 컬럼 정의문에서 사용된 문자
크기를 사용해서 출력이 된다. ENUM 컬럼에는 문자 셋과 콜레션이 할당될 수 있다는
점을 알아두자. 바이너리 또는 문자 크기를 구분하는 콜레션의 경우, 문자의 크기는
컬럼에 값을 할당할 때 그 고려가 된다.
 
만일 숫자 문맥에 있는 ENUM 값을 추출하는 경우에는, 그 컬럼 값의 인덱스가 리턴된다.
예를 들면, 여러분은 아래와 같이 ENUM 컬럼에서 숫자 값을 추출할 수가 있다:
mysql> SELECT enum_col+0 FROM tbl_name;
만일 어떤 숫자를 ENUM 컬럼에 저장한다면, 그 숫자는 인덱스 형태로 취급되며,
저장된 값은 그 인덱스를 가지고서 계산(enumeration) 맴버가 된다.
(하지만, 이것은 LOAD DATA과는 동작을 하지 않는데, 이것은 모든 입력 값을 스트링
형태로 취급하기 때문이다.) 숫자와 같은 계산 값을 가지고 ENUM 컬럼을 정의하는 것은
권고할 만한 것이 아니다. 예를 들면, 아래에 있는 컬럼은 스트링 값 '0', '1', 그리고 '2'를
가지는 계산 멤버를 가지고 있지만, 숫자 인덱스 값이 1, 2, 그리고 3이 된다:
numbers ENUM('0','1','2')
ENUM 값은 컬럼 지정문에서 계산 멤버가 리스트 되어 있는 순서대로 저장된다. 
(달리 말하면, ENUM 값은 자신의 인덱스 번호에 따라서 저장된다.) 
예를 들면, ENUM('a', 'b')에 대해서는 'a' 가 'b' 보다 전에 정렬이 되지만, ENUM('b', 'a')의 
경우에는 'b'가 'a' 보다 전에 정렬이 된다. 빈 스트링은 비어 있지 않은 스트링 보다 앞서서 
정렬이 되고, NULL 값은 다른 모든 계산 값 보다 먼저 정렬이 된다. 예상하지 못한 결과를 
피하기 위해서는, ENUM 리스트를 알파벳 순서로 지정을 한다. 또한, 컬럼이 인덱스 번호가 
아닌 사전적 순서로 정렬되도록 하기 위해서는 GROUP BY CAST(col AS CHAR) 또는 
GROUP BY CONCAT(col)를 사용할 수도 있다. 
 
만일 ENUM 컬럼에 대해서 모든 가능한 값이 어떤 것이 있는지를 알아보고자 한다면,
SHOW COLUMNS FROM tbl_name LIKE enum_col 를 사용하고 그 결과로 나오는
Type 컬럼의 ENUM 정의문을 파스(parse) 하면 된다.